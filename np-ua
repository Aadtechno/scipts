properties([
    buildDiscarder(logRotator(
        artifactDaysToKeepStr: '',
        artifactNumToKeepStr: '',
        daysToKeepStr: '',
        numToKeepStr: '10'))
])

pipeline {
    agent any

    parameters {
        text(name: 'npe_uat',
             defaultValue: 'gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt',
             description: 'Provide source and destination GCS paths separated by comma.\n' +
                          'Example: gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt')
    }

    stages {
        stage("Parse & Validate") {
            steps {
                script {
                    def parts = params.npe_uat.split(",")
                    if (parts.size() != 2) {
                        error "Invalid input. Must provide exactly two comma-separated URIs."
                    }
                    env.SOURCE = parts[0].trim()
                    env.DEST   = parts[1].trim()

                    if (!env.SOURCE.startsWith("gs://") || !env.DEST.startsWith("gs://")) {
                        error "Both source and destination must start with gs://"
                    }

                    echo "Source : ${env.SOURCE}"
                    echo "Dest   : ${env.DEST}"
                }
            }
        }

        stage("Download file to Jenkins node") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    sh '''
                        set -xe
                        mkdir -p payload
                        gsutil cp "${SOURCE}" ./payload/
                        gsutil ls -l "${SOURCE}" || true
                        ls -lah ./payload
                    '''
                    stash name: 'artifact', includes: 'payload/**', allowEmpty: false
                }
            }
        }

        stage("Upload file to UAT") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    unstash 'artifact'
                    sh '''
                        set -xe
                        FILE=$(find ./payload -type f)
                        echo "Uploading $FILE -> ${DEST}"
                        gsutil cp "$FILE" "${DEST}"
                        gsutil ls -l "${DEST}" || true
                    '''
                }
            }
        }
    }
}
---------------------
properties([buildDiscarder(logRotator(numToKeepStr: '10'))])

pipeline {
  agent none

  parameters {
    // One pair per line: SRC,DST
    // Example:
    // gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
    // gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt
    text(name: 'npe_uat',
         defaultValue: '''gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt''',
         description: 'Each line = SRC_GCS_URI,DST_GCS_URI')
  }

  stages {

    stage('Download on NPE') {
      agent { label 'npe-label' } // <-- your NPE node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          sh '''
            set -e
            rm -rf jars && mkdir -p jars
            # For each line: SRC,DST -> download SRC to jars/<basename>
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              echo "Downloading: $SRC -> jars/$BASENAME"
              gsutil cp "$SRC" "jars/$BASENAME"
            done
          '''
          stash name: 'jars', includes: 'jars/**'
        }
      }
    }

    stage('Upload on UAT (sequential)') {
      agent { label 'uat-label' } // <-- your UAT node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          deleteDir()
          unstash 'jars'
          sh '''
            set -e
            # For each line again: SRC,DST -> upload jars/<basename> to DST, then delete local
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              FILE="jars/$BASENAME"
              echo "Uploading: $FILE -> $DST"
              gsutil cp "$FILE" "$DST"
              gsutil ls -l "$DST" || true
              rm -f "$FILE"
              echo "Done: $BASENAME"
              echo "---------------------"
            done
          '''
        }
      }
    }
  }
}
----
properties([
  parameters([
    text(
      name: 'npe_uat',
      defaultValue: '',
      description: 'Each line = SRC_GCS_URI,DST_GCS_URI'
    )
  ])
])

// Update these labels:
def NPE = 'npe-label'
def UAT = 'uat-label'

// Parse & validate input up-front
def lines = (params.npe_uat ?: '').trim().readLines().findAll { it.trim() }
if (lines.isEmpty()) {
  error "Parameter 'npe_uat' is empty. Provide one or more lines like: gs://npe/.../a.txt,gs://uat/.../a.txt"
}

echo "Promoting ${lines.size()} item(s) NPE → UAT..."

lines.eachWithIndex { line, i ->
  def parts = line.split(',', 2)
  if (parts.size() != 2) { error "Invalid line (need SRC,DST): '${line}'" }

  def SRC = parts[0].trim()
  def DST = parts[1].trim()
  if (!(SRC.startsWith('gs://') && DST.startsWith('gs://'))) {
    error "Both SRC and DST must start with gs:// (got SRC='${SRC}', DST='${DST}')"
  }

  def BN   = SRC.tokenize('/').last()
  def ST   = "item-${i}-${BN}"
  def idx  = "${i+1}/${lines.size()}"

  stage("Promote ${BN} (${idx})") {

    // NPE: download & stash
    node(NPE) {
      dir('npe-to-uat') {
        deleteDir()
        sh """
          set -e
          mkdir -p jars
          echo "[NPE] ${SRC} -> jars/${BN}"
          gsutil -q cp "${SRC}" "jars/${BN}"
          test -f "jars/${BN}"
        """
        stash name: ST, includes: "jars/${BN}"
      }
    }

    // UAT: unstash, upload, verify, clean
    node(UAT) {
      dir('npe-to-uat') {
        deleteDir()
        unstash ST
        sh """
          set -e
          FILE="jars/${BN}"
          echo "[UAT] ${FILE} -> ${DST}"
          gsutil -q cp "$FILE" "${DST}"
          gsutil ls -l "${DST}" || true
          rm -f "$FILE"
          echo "[OK] ${BN} done"
        """
      }
    }
  }
}

echo "All items processed successfully."
------------------------------------------
// === Parameters ===
properties([
  parameters([
    text(
      name: 'modules',
      defaultValue: 'moduleA\nmoduleB',
      description: 'One module name per line (no commas).'
    )
  ])
])

// === Hard-coded endpoints (edit if hosts/paths change) ===
def UAT_BASE     = 'https://global-batch-app.uat.dfds/config/bu/ca-uat-prd/modules'
def PROMOTE_BASE = 'https://global-batch-app.alpha.dfds/config/bu/alpha-npe/destbu/apps-ic-bat-ca-uat-prd/modules'

// === Waits ===
def SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC = 30   // per module
def WAIT_BEFORE_PUBLISH_MIN                 = 8    // per module

// === Auth (optional for now) ===
// If you already have a Jenkins "Secret text" credential for the bearer token,
// put its ID below and uncomment the withCredentials block in the main run loop.
def TOKEN_CRED_ID = null   // e.g., 'CONFIG_API_TOKEN'

// ===== Helpers =====
def httpPost = { label, url, tokenValue ->
  echo "[${label}] POST ${url}"
  def authHdr = (tokenValue?.trim()) ? "-H 'Authorization: Bearer ${tokenValue.trim()}'" : ""
  sh """
    set -euo pipefail
    STATUS=\$(curl -sS -X POST ${authHdr} -H 'Content-Type: application/json' -w '%{http_code}' -o /dev/null '${url}')
    echo "HTTP_STATUS=\$STATUS"
    case "\$STATUS" in
      2*) exit 0 ;;
      *)  echo "Request failed with HTTP \$STATUS for ${label} (${url})" >&2; exit 1 ;;
    esac
  """
}

// ===== Main =====
node { // run on any node; switch to a label if you like
  stage('Init & Parse') {
    // Parse modules: one per line, trim, unique
    modules = (params.modules ?: '').trim().readLines()
               .collect { it.trim() }
               .findAll { it }
               .unique()

    if (modules.isEmpty()) {
      error "Parameter 'modules' is empty. Provide one module name per line."
    }
    echo "Modules to process: ${modules}"
    echo "UAT base: ${UAT_BASE}"
    echo "PROMOTE base: ${PROMOTE_BASE}"
    echo "Per-module waits: ${SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC}s then ${WAIT_BEFORE_PUBLISH_MIN}m"
  }

  // If you have a token credential, uncomment this block and set TOKEN_CRED_ID above.
  // def tokenValue = ''
  // if (TOKEN_CRED_ID) {
  //   withCredentials([string(credentialsId: TOKEN_CRED_ID, variable: 'CONFIG_API_TOKEN')]) {
  //     tokenValue = env.CONFIG_API_TOKEN
  //   }
  // }

  // No-credential default:
  def tokenValue = ''

  modules.eachWithIndex { m, i ->
    def idx = "${i+1}/${modules.size()}"

    stage("Unpublish — ${m} (${idx})") {
      def url = "${UAT_BASE}/${m}/unpublish"
      httpPost("UAT Unpublish ${m}", url, tokenValue)
    }

    stage("Promote — ${m} (${idx})") {
      sleep time: SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC, unit: 'SECONDS'
      def url = "${PROMOTE_BASE}/${m}/promote"
      httpPost("NPE→UAT Promote ${m}", url, tokenValue)
    }

    stage("Wait — ${m} (${idx})") {
      echo "Waiting ${WAIT_BEFORE_PUBLISH_MIN} minute(s) before publishing ${m}…"
      sleep time: WAIT_BEFORE_PUBLISH_MIN, unit: 'MINUTES'
    }

    stage("Publish — ${m} (${idx})") {
      def url = "${UAT_BASE}/${m}/publish"
      httpPost("UAT Publish ${m}", url, tokenValue)
    }
  }

  stage('Done') {
    echo "✅ All modules processed successfully."
  }
}

