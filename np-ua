properties([
    buildDiscarder(logRotator(
        artifactDaysToKeepStr: '',
        artifactNumToKeepStr: '',
        daysToKeepStr: '',
        numToKeepStr: '10'))
])

pipeline {
    agent any

    parameters {
        text(name: 'npe_uat',
             defaultValue: 'gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt',
             description: 'Provide source and destination GCS paths separated by comma.\n' +
                          'Example: gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt')
    }

    stages {
        stage("Parse & Validate") {
            steps {
                script {
                    def parts = params.npe_uat.split(",")
                    if (parts.size() != 2) {
                        error "Invalid input. Must provide exactly two comma-separated URIs."
                    }
                    env.SOURCE = parts[0].trim()
                    env.DEST   = parts[1].trim()

                    if (!env.SOURCE.startsWith("gs://") || !env.DEST.startsWith("gs://")) {
                        error "Both source and destination must start with gs://"
                    }

                    echo "Source : ${env.SOURCE}"
                    echo "Dest   : ${env.DEST}"
                }
            }
        }

        stage("Download file to Jenkins node") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    sh '''
                        set -xe
                        mkdir -p payload
                        gsutil cp "${SOURCE}" ./payload/
                        gsutil ls -l "${SOURCE}" || true
                        ls -lah ./payload
                    '''
                    stash name: 'artifact', includes: 'payload/**', allowEmpty: false
                }
            }
        }

        stage("Upload file to UAT") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    unstash 'artifact'
                    sh '''
                        set -xe
                        FILE=$(find ./payload -type f)
                        echo "Uploading $FILE -> ${DEST}"
                        gsutil cp "$FILE" "${DEST}"
                        gsutil ls -l "${DEST}" || true
                    '''
                }
            }
        }
    }
}
---------------------
properties([buildDiscarder(logRotator(numToKeepStr: '10'))])

pipeline {
  agent none

  parameters {
    // One pair per line: SRC,DST
    // Example:
    // gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
    // gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt
    text(name: 'npe_uat',
         defaultValue: '''gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt''',
         description: 'Each line = SRC_GCS_URI,DST_GCS_URI')
  }

  stages {

    stage('Download on NPE') {
      agent { label 'npe-label' } // <-- your NPE node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          sh '''
            set -e
            rm -rf jars && mkdir -p jars
            # For each line: SRC,DST -> download SRC to jars/<basename>
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              echo "Downloading: $SRC -> jars/$BASENAME"
              gsutil cp "$SRC" "jars/$BASENAME"
            done
          '''
          stash name: 'jars', includes: 'jars/**'
        }
      }
    }

    stage('Upload on UAT (sequential)') {
      agent { label 'uat-label' } // <-- your UAT node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          deleteDir()
          unstash 'jars'
          sh '''
            set -e
            # For each line again: SRC,DST -> upload jars/<basename> to DST, then delete local
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              FILE="jars/$BASENAME"
              echo "Uploading: $FILE -> $DST"
              gsutil cp "$FILE" "$DST"
              gsutil ls -l "$DST" || true
              rm -f "$FILE"
              echo "Done: $BASENAME"
              echo "---------------------"
            done
          '''
        }
      }
    }
  }
}
----
properties([
  parameters([
    text(
      name: 'npe_uat',
      defaultValue: '',
      description: 'Each line = SRC_GCS_URI,DST_GCS_URI'
    )
  ])
])

// Update these labels:
def NPE = 'npe-label'
def UAT = 'uat-label'

// Parse & validate input up-front
def lines = (params.npe_uat ?: '').trim().readLines().findAll { it.trim() }
if (lines.isEmpty()) {
  error "Parameter 'npe_uat' is empty. Provide one or more lines like: gs://npe/.../a.txt,gs://uat/.../a.txt"
}

echo "Promoting ${lines.size()} item(s) NPE → UAT..."

lines.eachWithIndex { line, i ->
  def parts = line.split(',', 2)
  if (parts.size() != 2) { error "Invalid line (need SRC,DST): '${line}'" }

  def SRC = parts[0].trim()
  def DST = parts[1].trim()
  if (!(SRC.startsWith('gs://') && DST.startsWith('gs://'))) {
    error "Both SRC and DST must start with gs:// (got SRC='${SRC}', DST='${DST}')"
  }

  def BN   = SRC.tokenize('/').last()
  def ST   = "item-${i}-${BN}"
  def idx  = "${i+1}/${lines.size()}"

  stage("Promote ${BN} (${idx})") {

    // NPE: download & stash
    node(NPE) {
      dir('npe-to-uat') {
        deleteDir()
        sh """
          set -e
          mkdir -p jars
          echo "[NPE] ${SRC} -> jars/${BN}"
          gsutil -q cp "${SRC}" "jars/${BN}"
          test -f "jars/${BN}"
        """
        stash name: ST, includes: "jars/${BN}"
      }
    }

    // UAT: unstash, upload, verify, clean
    node(UAT) {
      dir('npe-to-uat') {
        deleteDir()
        unstash ST
        sh """
          set -e
          FILE="jars/${BN}"
          echo "[UAT] ${FILE} -> ${DST}"
          gsutil -q cp "$FILE" "${DST}"
          gsutil ls -l "${DST}" || true
          rm -f "$FILE"
          echo "[OK] ${BN} done"
        """
      }
    }
  }
}

echo "All items processed successfully."
------------------------------------------
// ──────────────────────────────────────────────────────────────────────────────
// Jenkins Scripted Pipeline: NPE → UAT module promotion (per-module flow)
// Tokens: PROD token used for Unpublish/Publish; NPE token used for Promote.
// Steps per module: Unpublish → 30s → Promote → 8m → Publish
// ──────────────────────────────────────────────────────────────────────────────

properties([
  parameters([
    text(
      name: 'modules',
      defaultValue: 'moduleA\nmoduleB',
      description: 'One module name per line (no commas).'
    )
  ])
])

// ── Hard-coded API bases (edit if hosts/paths change) ────────────────────────
final String UAT_BASE     = 'https://global-batch-app.uat.dfds/config/bu/ca-uat-prd/modules'
final String PROMOTE_BASE = 'https://global-batch-app.alpha.dfds/config/bu/alpha-npe/destbu/apps-ic-bat-ca-uat-prd/modules'

// ── Waits ────────────────────────────────────────────────────────────────────
final int SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC = 30   // per module
final int WAIT_BEFORE_PUBLISH_MIN                 = 8    // per module

// ── OAuth token endpoints + Jenkins credential IDs ───────────────────────────
// Store these as Jenkins "Username with password":
//   - ID: CLIENT_API_SNAPSHOT        (username = CLIENT_ID, password = CLIENT_SECRET)  → NPE token
//   - ID: CLIENT_API_SNAPSHOT_PROD   (username = CLIENT_ID, password = CLIENT_SECRET)  → PROD token
final String NPE_TOKEN_URL  = 'https://fedssoqa.equifax.com/as/token.oauth2'
final String NPE_CRED_ID    = 'CLIENT_API_SNAPSHOT'
final String PROD_TOKEN_URL = 'https://fedsso.equifax.com/as/token.oauth2'
final String PROD_CRED_ID   = 'CLIENT_API_SNAPSHOT_PROD'

// ── Helpers ──────────────────────────────────────────────────────────────────
/** Obtain OAuth2 client-credentials token using curl + jq from given URL/cred. */
String fetchToken(String oauthUrl, String credId, String label) {
  String token = ''
  withCredentials([usernamePassword(credentialsId: credId, usernameVariable: 'CLIENT_ID', passwordVariable: 'CLIENT_SECRET')]) {
    String body = "client_id=${env.CLIENT_ID}&client_secret=${env.CLIENT_SECRET}&grant_type=client_credentials"
    token = sh(
      label: "Generate OAuth token (${label})",
      script: """
        set -euo pipefail
        curl -sS -X POST \\
          -H 'Content-Type: application/x-www-form-urlencoded' \\
          -d '${body}' '${oauthUrl}' | jq -r '.access_token'
      """,
      returnStdout: true
    ).trim()
  }
  if (!token) { error "Failed to obtain OAuth token for ${label} (empty token)." }
  return token
}

/** Minimal POST helper with Bearer token; fails on non-2xx. */
void postWithToken(String label, String url, String token) {
  echo "[${label}] POST ${url}"
  sh """
    set -euo pipefail
    STATUS=\$(curl -sS -X POST \\
      -H 'Authorization: Bearer ${token}' \\
      -H 'Content-Type: application/json' \\
      -w '%{http_code}' -o /dev/null '${url}')
    echo "HTTP_STATUS=\$STATUS"
    case "\$STATUS" in 2*) : ;; *) echo "Request failed: \$STATUS (${label})" >&2; exit 1;; esac
  """
}

// ── Main ─────────────────────────────────────────────────────────────────────
node {
  stage('Init & Tokens') {
    // Parse module list (one per line)
    modules = (params.modules ?: '')
                .trim()
                .readLines()
                .collect { it.trim() }
                .findAll { it }
                .unique()

    if (modules.isEmpty()) {
      error "Parameter 'modules' is empty. Provide one module per line."
    }

    echo "Modules: ${modules}"
    echo "UAT base     : ${UAT_BASE}"
    echo "PROMOTE base : ${PROMOTE_BASE}"
    echo "Per-module waits: ${SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC}s then ${WAIT_BEFORE_PUBLISH_MIN}m"

    // Fetch both tokens once
    NPE_TOKEN  = fetchToken(NPE_TOKEN_URL,  NPE_CRED_ID,  'NPE')
    PROD_TOKEN = fetchToken(PROD_TOKEN_URL, PROD_CRED_ID, 'PROD')
    echo '✅ Obtained NPE and PROD tokens.'
  }

  // Per-module flow using the appropriate token per step
  modules.eachWithIndex { m, i ->
    def idx = "${i+1}/${modules.size()}"

    stage("Unpublish — ${m} (${idx})") {
      postWithToken("UAT Unpublish ${m}", "${UAT_BASE}/${m}/unpublish", PROD_TOKEN)
    }

    stage("Promote — ${m} (${idx})") {
      sleep time: SLEEP_BETWEEN_UNPUBLISH_AND_PROMOTE_SEC, unit: 'SECONDS'
      postWithToken("NPE→UAT Promote ${m}", "${PROMOTE_BASE}/${m}/promote", NPE_TOKEN)
    }

    stage("Wait — ${m} (${idx})") {
      echo "Waiting ${WAIT_BEFORE_PUBLISH_MIN} minute(s) before publishing ${m}…"
      sleep time: WAIT_BEFORE_PUBLISH_MIN, unit: 'MINUTES'
    }

    stage("Publish — ${m} (${idx})") {
      postWithToken("UAT Publish ${m}", "${UAT_BASE}/${m}/publish", PROD_TOKEN)
    }
  }

  stage('Done') {
    echo '✅ All modules processed successfully.'
  }
}


