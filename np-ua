properties([
    buildDiscarder(logRotator(
        artifactDaysToKeepStr: '',
        artifactNumToKeepStr: '',
        daysToKeepStr: '',
        numToKeepStr: '10'))
])

pipeline {
    agent any

    parameters {
        text(name: 'npe_uat',
             defaultValue: 'gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt',
             description: 'Provide source and destination GCS paths separated by comma.\n' +
                          'Example: gs://npe-bucket/folder/a.txt,gs://uat-bucket/folder/a.txt')
    }

    stages {
        stage("Parse & Validate") {
            steps {
                script {
                    def parts = params.npe_uat.split(",")
                    if (parts.size() != 2) {
                        error "Invalid input. Must provide exactly two comma-separated URIs."
                    }
                    env.SOURCE = parts[0].trim()
                    env.DEST   = parts[1].trim()

                    if (!env.SOURCE.startsWith("gs://") || !env.DEST.startsWith("gs://")) {
                        error "Both source and destination must start with gs://"
                    }

                    echo "Source : ${env.SOURCE}"
                    echo "Dest   : ${env.DEST}"
                }
            }
        }

        stage("Download file to Jenkins node") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    sh '''
                        set -xe
                        mkdir -p payload
                        gsutil cp "${SOURCE}" ./payload/
                        gsutil ls -l "${SOURCE}" || true
                        ls -lah ./payload
                    '''
                    stash name: 'artifact', includes: 'payload/**', allowEmpty: false
                }
            }
        }

        stage("Upload file to UAT") {
            steps {
                dir("${WORKSPACE}/jenkins/npe-to-uat/") {
                    unstash 'artifact'
                    sh '''
                        set -xe
                        FILE=$(find ./payload -type f)
                        echo "Uploading $FILE -> ${DEST}"
                        gsutil cp "$FILE" "${DEST}"
                        gsutil ls -l "${DEST}" || true
                    '''
                }
            }
        }
    }
}
---------------------
properties([buildDiscarder(logRotator(numToKeepStr: '10'))])

pipeline {
  agent none

  parameters {
    // One pair per line: SRC,DST
    // Example:
    // gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
    // gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt
    text(name: 'npe_uat',
         defaultValue: '''gs://npebucket/txt1.txt,gs://uatbucket/txt1.txt
gs://npebucket/txt2.txt,gs://uatbucket/txt2.txt''',
         description: 'Each line = SRC_GCS_URI,DST_GCS_URI')
  }

  stages {

    stage('Download on NPE') {
      agent { label 'npe-label' } // <-- your NPE node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          sh '''
            set -e
            rm -rf jars && mkdir -p jars
            # For each line: SRC,DST -> download SRC to jars/<basename>
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              echo "Downloading: $SRC -> jars/$BASENAME"
              gsutil cp "$SRC" "jars/$BASENAME"
            done
          '''
          stash name: 'jars', includes: 'jars/**'
        }
      }
    }

    stage('Upload on UAT (sequential)') {
      agent { label 'uat-label' } // <-- your UAT node label
      steps {
        dir("${WORKSPACE}/npe-to-uat") {
          deleteDir()
          unstash 'jars'
          sh '''
            set -e
            # For each line again: SRC,DST -> upload jars/<basename> to DST, then delete local
            echo "$npe_uat" | while IFS=, read -r SRC DST; do
              [ -z "$SRC" ] && continue
              BASENAME=$(basename "$SRC")
              FILE="jars/$BASENAME"
              echo "Uploading: $FILE -> $DST"
              gsutil cp "$FILE" "$DST"
              gsutil ls -l "$DST" || true
              rm -f "$FILE"
              echo "Done: $BASENAME"
              echo "---------------------"
            done
          '''
        }
      }
    }
  }
}
----
properties([
  parameters([
    text(
      name: 'npe_uat',
      defaultValue: '',
      description: 'Each line = SRC_GCS_URI,DST_GCS_URI'
    )
  ])
])

// Update these labels:
def NPE = 'npe-label'
def UAT = 'uat-label'

// Parse & validate input up-front
def lines = (params.npe_uat ?: '').trim().readLines().findAll { it.trim() }
if (lines.isEmpty()) {
  error "Parameter 'npe_uat' is empty. Provide one or more lines like: gs://npe/.../a.txt,gs://uat/.../a.txt"
}

echo "Promoting ${lines.size()} item(s) NPE â†’ UAT..."

lines.eachWithIndex { line, i ->
  def parts = line.split(',', 2)
  if (parts.size() != 2) { error "Invalid line (need SRC,DST): '${line}'" }

  def SRC = parts[0].trim()
  def DST = parts[1].trim()
  if (!(SRC.startsWith('gs://') && DST.startsWith('gs://'))) {
    error "Both SRC and DST must start with gs:// (got SRC='${SRC}', DST='${DST}')"
  }

  def BN   = SRC.tokenize('/').last()
  def ST   = "item-${i}-${BN}"
  def idx  = "${i+1}/${lines.size()}"

  stage("Promote ${BN} (${idx})") {

    // NPE: download & stash
    node(NPE) {
      dir('npe-to-uat') {
        deleteDir()
        sh """
          set -e
          mkdir -p jars
          echo "[NPE] ${SRC} -> jars/${BN}"
          gsutil -q cp "${SRC}" "jars/${BN}"
          test -f "jars/${BN}"
        """
        stash name: ST, includes: "jars/${BN}"
      }
    }

    // UAT: unstash, upload, verify, clean
    node(UAT) {
      dir('npe-to-uat') {
        deleteDir()
        unstash ST
        sh """
          set -e
          FILE="jars/${BN}"
          echo "[UAT] ${FILE} -> ${DST}"
          gsutil -q cp "$FILE" "${DST}"
          gsutil ls -l "${DST}" || true
          rm -f "$FILE"
          echo "[OK] ${BN} done"
        """
      }
    }
  }
}

echo "All items processed successfully."
